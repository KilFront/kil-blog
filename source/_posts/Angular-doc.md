---
title: Angular-doc
date: 2020-01-13 17:57:58
categories:
- Angular
tags:
- Angular
---
# 知识
## 组件
- 一个组件类
- 一个HTML模版
- 组件专属的样式

## 模板语法 
### 结构型指令
特点：
+ 带有 * 的指令
+ 结构型指令会通过添加、删除和操纵它们的宿主元素等方式塑造或重塑 DOM 的结构

list
- *ngFor 
- *ngIf

### 插值语法 
插值  { {} } 会把属性的值作为文本渲染出来

### 属性绑定语法
属性绑定语法 [], 在模板表达式中使用属性值
[title]="product.name"

### 事件绑定
事件绑定是通过把事件名称包裹在圆括号 () 中

# 大漠穷秋-angular教程
在计算机领域，任何东西研究到最底层都和“算法”、“数据结构”、“设计模式”有关。而就我所知，很多朋友并不具备研究这些内容的基础知识，不过是白白浪费自己的时间而已。
带你学会开车，而不是教你设计发动机
这个系列的内容非常看重“概念模型”（Mental Model）的构建。“核心价值”
并没有掌握这门框架的精髓

## debug
请把你本地 launch.json 文件里面的内容改成这样：
``` json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "chrome",
            "request": "launch",
            "name": "Chrome",
            "url": "http://localhost:4200",
            "webRoot": "${workspaceRoot}"
        }
    ]
}
```

## Schematics 与代码生成器
@angular/cli 内置的 add 命令

## [组件]概念
几乎所有前端框架都在玩`组件化`，而且最近都不约而同地选择了“标签化”这种思路，Angular 也不例外。

对新版本的 Angular 来说，一切都是围绕着“组件化”展开的，组件是 Angular 的核心概念模型。
``` ts
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {
}  
```
+ @Component：这是一个 Decorator（装饰器），其作用类似于 Java 里面的 Annotation（注解）。Decorator 这个特性目前处于 Stage 2（草稿）状态，还不是 ECMA 的正式规范

## [组件]把CSS预编译改成SASS
方式一
创建项目时指定 scss

方式二
+ angular-cli.json 里面的 styleExt 改成 scss
+ angular-cli.json 里面的 styles.css 后缀改成 .scss
+ src 下面 style.css 改成 style.scss
+ app.component.scss
+ app.component.ts 里面对应修改

## [组件]模板的使用
`模板是编写Angular组件最重要的一环`
+ 对比各种 JS 模板引擎的设计思路
+ Mustache（八字胡）语法
+ 模板内的局部变量
+ 属性绑定、事件绑定、双向绑定
+ 在模板里面使用结构型指令 *ngIf、*ngFor、ngSwitch
+ 在模板里面使用属性型指令 NgClass、NgStyle、NgModel
+ 在模板里面使用管道格式化数据
+ 一些小 feature：安全导航、非空断言

对比各种 JS 模板引擎的设计思路
几乎每一款前端框架都会提供自己的模板语法：
+ 在 jQuery 如日中天的时代，有 Handlebars 那种功能超强的模板
+ React 推崇 JSX 模板语法
+ 当然还有 Angular 提供的那种与“指令”紧密结合的模板语法
综合来说，无论是哪一种前端模板，大家都比较推崇“轻逻辑”（logic-less）的设计思路。

简而言之，所谓“轻逻辑”就是说，你不能在模板里面编写非常复杂的 JavaScript 表达式。比如，Angular 的模板语法就有规定：

+ 你不能在模板里面 new 对象
+ 不能使用 =、+=、-= 这类的表达式
+ 不能用 ++、-- 运算符
+ 不能使用位运算符

为什么要“轻逻辑”？

最重要的原因是怕影响运行性能，因为模板可能会被执行很多次。
``` html
<ul>
    <li *ngFor="let race of races">
        {{race.name}}
    </li>
</ul>
```
很明显，浏览器不认识 *ngFor 和 {{…}} 这种语法，因此必须在浏览器里面进行“编译”，获得对应的模板函数，然后再把数据传递给模板函数，最终结合起来获得一堆 HTML 标签，然后才能把这一堆标签插入到 DOM 树里面去。

如果启用了 AOT，处理的步骤有一些变化，@angular/cli 会对模板进行“静态编译”，避免在浏览器里面动态编译的过程。

而 Handlebars 这种模板引擎完全是运行时编译模板字符串的，你可以编写以下代码：

``` ts
//定义模板字符串
var source=`
<ul>
    {{#each races}}
        <li>{{name}}</li>
    {{/each}}
</ul>
`;

//在运行时把模板字符串编译成 JS 函数
var templateFn=Handlebars.compile(source);

//把数据传给模板函数，获得最终的 HTML
var html=templateFn([
    {name:'人族'},
    {name:'神族'},
    {name:'虫族'}
]);
```
注意到 Handlebars.compile 这个调用了吧？这个地方的本质是在运行时把模板字符串“编译”成了一个 JS 函数。

鉴于 JS 解释执行的特性，你可能会担忧这里会有性能问题。这种担忧是合理的，但是 Handlebars 是一款非常优秀的模板引擎，它在内部做了各种优化和缓存处理。模板字符串一般只会在第一次被调用的时候编译一次，Handlebars 会把编译好的函数缓存起来，后面再次调用的时候会从缓存里面获取，而不会多次进行“编译”。

上面我们多次提到了“编译”这个词，因此很显然这里有一个东西是无法避免的，那就是我们必须提供一个 JS 版的“编译器”，让这个“编译器”运行在浏览器里面，这样才能在运行时把用户编写的模板字符串“编译”成模板函数。

有一些模板引擎会真的去用 JS 编写一款“编译器”出来，比如 Angular 和 Handlebars，它们都真的编写了一款 JS（TS）版的编译器。而有一些简单的模板引擎，例如 Underscore 里面的模板函数，只是用正则表达式做了字符串替换而已，显得特别简陋。这种简陋的模板引擎对模板的写法有非常多的限制，因为它不是真正的编译器，能支持的语法特性非常有限。

因此，评估一款模板引擎的强弱，最核心的东西就是评估它的“编译器”做得怎么样。但是不管怎么说，毕竟是 JS 版的“编译器”，我们不可能把它做得像 G++ 那么强大，也没有必要做得那么强大，因为这个 JS 版的编译器需要在浏览器里面运行，搞得太复杂浏览器拖不动！

以上就是为什么大多数模板引擎都要强调“轻逻辑”的最根本原因。

对于 Angular 来说，强调“轻逻辑”还有另一个原因：在组件的整个生命周期里面，模板函数会被执行很多次。你可以想象，Angular 每次要刷新组件外观的时候，都需要去调用一下模板函数，如果你在模板里面编写了非常复杂的代码，一定会增加渲染时间，用户一定会感到界面有“卡顿”。

人眼的视觉延迟大约是 100ms 到 400ms 之间，如果整个页面的渲染时间超过 400ms，界面基本上就卡得没法用了。有一些做游戏的开发者会追求 60fps 刷新率的细腻感觉，60 分之 1 秒约等于 16.7ms，如果 UI 整体的渲染时间超过了 16.7ms，就没法达到这个要求了。

轻逻辑（logic-less）带来了效率的提升，也带来了一些不方便，比如很多模板引擎都实现了 if 语句，但是没有实现 else，因此开发者们在编写复杂业务逻辑的时候模板代码会显得非常啰嗦。

目前来说，并没有完美的方案能同时兼顾运行效率和语法表现能力，这里只能取一个平衡。


### Mustache 语法
Mustache 语法也就是你们说的双花括号语法 {{…}}，老外觉得它像八字胡子，很奇怪啊，难道老外喜欢侧着头看东西？

好消息是，很多模板引擎都接受了 Mustache 语法，这样一来学习量又降低了不少，开心吧？

关于 Mustache 语法，你需要掌握 3 点：

+ 它可以获取到组件里面定义的属性值
+ 它可以自动计算简单的数学表达式，如加减乘除、取模
+ 它可以获得方法的返回值

AngularJS 是第一个把“双向数据绑定”这个特性带到前端来的框架，这也是 AngularJS 当年最受开发者追捧的特性，之一。

根据 AngularJS 团队当年讲的故事，“双向数据绑定”这个特性可以大幅度压缩前端代码的规模。大家可以回想一下 jQuery 时代的做法，如果要实现类似的效果，是不是要自己去编写大量的代码？尤其是那种大规模的表单，一大堆的赋值和取值操作，都是非常丑陋的“面条”代码，而有了“双向数据绑定”特性之后，一个绑定表达式就搞定。

目前，主流的几款前端框架都已经接受了“双向数据绑定”这个特性。

当然，也有一些人不喜欢“双向数据绑定”，还有人专门写了文章来进行批判，也算是前端一景。

在模板里面使用`结构型指令`
Angular 有 3 个内置的结构型指令：*ngIf、*ngFor、ngSwitch。ngSwitch 的语法比较啰嗦，使用频率小一些。

特别注意：一个 HTML 标签上只能同时使用一个结构型的指令。

因为“结构型”指令会修改 DOM 结构，如果在一个标签上使用多个结构型指令，大家都一起去修改 DOM 结构，到时候到底谁说了算？

那么需要在同一个 HTML 上使用多个结构型指令应该怎么办呢？有两个办法：

加一层空的 div 标签
加一层 <ng-container>

在模板里面使用`属性型指令`
使用频率比较高的 3 个内置指令是：NgClass、NgStyle、NgModel。




