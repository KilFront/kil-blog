---
title: advanced
date: 2020-07-10 18:18:35
categories:
- Front-End
tags:
- Front-End
- JavaScript
---

# JS
## 语言通识
`{% asset_img language.png%}`

`{% asset_img type.png%}`

`{% asset_img js01.png%}`

## 乔姆斯基谱系
乔姆斯基谱系：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：
0- 型文法（无限制文法或短语结构文法）包括所有的文法。
1- 型文法（上下文相关文法）生成上下文相关语言。
2- 型文法（上下文无关文法）生成上下文无关语言。
3- 型文法（正规文法）生成正则语言。

## BNF
巴科斯范式 Backus Normal Form

是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

`{% asset_img bnf.png %}`
`{% asset_img bnf02.png %}`

### 理解
[链接](https://www.cnblogs.com/huiyenashen/p/4445676.html)
BNF 规定是推导规则(产生式)的集合，写为：

<符号> ::= <使用符号的表达式>
这里的 <符号> 是非终结符，而表达式由一个符号序列，或用指示选择的竖杠'|' 分隔的多个符号序列构成，每个符号序列整体都是左端的符号的一种可能的替代。从未在左端出现的符号叫做终结符。

基本原理
      BNF类似一种数学游戏：从一个符号开始（叫做起始标志，实例中常用S表示），然后给出替换前面符号的规则。BNF语法定义的语言只不过是一个字符串集合，你可以按照下述规则书写，这些规则叫做书写规范（生产式规则），形式如下：
      symbol := alternative1 | alternative2 ...
      每条规则申明:=左侧的符号必须被右侧的某一个可选项代替。替换项用“|”分割（有时用“::=”替换“:=”，但意思是一样的）。替换项通常有两个符号和终结符构成。之所以叫做终结符是因为没有针对他们的书写规范，他们是书写过程的终止（符号通常被叫做非终止符，也有人叫非终端）。


       BNF就是巴科特·瑙尔式的缩写， 在计算机的史前时代（1950s)，曾有一位大师，他奠定了现代计算机的基础，在他老人家的诸多成就之中，包括了对形式语言的研究，和发明了高级语言：FORTRAN。 为了纪念他老人家，我们把他提出的一套描述语言的方法叫做BNF。它以递归方式描述语言中的各种成分，凡遵守其规则的程序就可保证语法上的正确性。BNF由于其简洁、明了、科学而被广泛接受，成为描述各种程序设计语言的最常用的工具。
       其实BNF很简单，::=表示定义     |表示或    尖括号(<>)括起来的是非终结符 
　　所谓非终结符就是语言中某些抽象的概念不能直接出现在语言中的符号，终结符就是可以直接出现在语言中的符号。
　　比如：C语言的声明语句可以用BNF这样描述： 
　　<声明语句> ::= <类型><标识符>; | <类型><标识符>[<数字>]; 
　　这一句中<声明语句>这个非终结符被定义成了两种形式（上面用|隔开的两部分），同时在这里引入了三个终结符: 分号; 左方括号[，右方括号 ]。 
　　<类型> ::= <简单类型> | <指针类型> | <自定义类型> 
　　<指针类型> ::= <简单类型> * | <自定义类型> * 
　　<简单类型> ::= int|char|double|float|long|short|void 
　　<自定义类型> ::= enum<标识符>|struct<标识符>|union<标识符>|<标识符>
　　到这里就基本上把<类型>定义清楚了。

　　<数字> ::= 0x<十六进制数字串> | 0<八进制数字串> | <十进制数字串> 
　　<十六进制数字串> ::= <十六进制数字> | <十六进制数字串><十六进制数字> 
　　<八进制数字串> ::= <八进制数字> | <八进制数字串><八进制数字> 
　　<十进制数字串> ::= <十进制数字> | <十进制数字串><十进制数字> 
　　<十六进制数字> ::= <十进制数字> | A | B | C | D | E | F 
　　<十进制数字> ::= <八进制数字> | 8 | 9 
　　<八进制数字> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 
　　到这里就把<数字>定义清楚了 

　　<标识符> ::= <字母> | <标识符> <字母数字串> 
　　<字母数字串> ::= <字母>|<十进制数字>|<字母数字串><字母>|<字母数字串><十进制数字> 
　　<字母> ::= _ | <大写字母> | <小写字母> 
　　<小写字母> ::= a|b|c|d|e|f|g|h|i|j ……  
　　<大写字母> ::= A|B|C|D|E|F|G|H|I|J …… 
　　到此为止整个声明语句就定义完了（就是说已经没有非终结符了）。

         虽然看起来很繁，但前面定义的各种非终结符都可以很容易的在别的地方重用。比如，函数声明可以定义成下面的样子： 
　　<函数声明语句> ::= <类型><标识符>(<形参表>); 
　　<形参表> ::= <类型><标识符> | <形参表>,<形参表> 
　　只用两句就描述完了，所以BNF实际上比用自然语言要简练得多（整个C语言只用一二百句就可以描述清楚），而且相当的精确，不会有自然语言中那种模棱两可的表达。如果你对BNF比较敏感的话，会发现C里面的标识符不能由数字开头，而且在C里面下划线是被当做字母看待的（也就是说能用字母的地方都可以用下划线）。

## 产生式
 在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句

几种结构的组合产生一个新的结构，叫语法定义也叫语法产生式。

## 终结符
终结符： 最终在代码中出现的字符（ https://zh.wikipedia.org/wiki/ 終結符與非終結符)

不是代码终止的意思

# JS类型
## String
`{% asset_img code.png %}`
ASCII 0-127个字符 ；出来的较早，计算机的基础
Unicode 世界编码集
GB 国标里的字符码点跟Unicode码点不一致

UTF8 
8个比特位，1个字节，默认用一个字节表示一个字符

UTF16
16个比特位，2个字节表示一个字符
`{% asset_img utf.png %}`

控制位
`{% asset_img utf02.pngs %}`


# 浏览器工作原理
## 浏览器总论
`{% asset_img browser.png %}`
最后显示在计算机上的是图片的形式 Bitmap，最后传给显卡驱动设备，转换成人眼可识别的光信号。

浏览器目标：
从URL -> Bitmap （过程是浏览器渲染的基础流程）

## 状态机
有限状态机**处理字符串**
`{% asset_img state.png %}`

意义：在各个状态加入自己的逻辑，处理业务

debug 添加监视
`{% asset_img state02.png %}`

## HTTP
浏览器的第一步：http状态解析
- http状态
- header

### 网络模型
`{% asset_img http.jpg %}`

``` js
new Request({
  method: "POST",     // TCP 层
  host: "127.0.0.1",  // IP 层
  post: "8088"        // TCP 层
  path: "/"        // method 和 path 都是HTTP协议要求的
  headers: {
    ["X-Foo2"]: "customed"  // HTTP协议要求
  }
})
```


### TCP与IP的一些基础知识
- 流
- 端口
  每一个软件都会从网卡去拿数据，哪一个数据是分配给哪一个软件的，需要用到端口概念
- node 对应 require('net')

- 包
  TCP 传输的就是一个一个数据包的概念
- IP 地址
  数据包 从那到那
- node没有，node 调用C++ 库。libnet/libpcap
  libnet: 负责构造IP包并且发送
  libpcap: 负责从网卡抓所有的流经你的网卡的IP包


### HTTP
- request
- response

必须先由客户端发起一个 request，服务端发送一个 response

HTTP 协议是文本型的协议，所有内容都是字符串

method: GET/POST

#### http协议 request
`{% asset_img request.png %}`

第一步HTTP请求总结
- 设计一个HTTP请求的类
- content type是一个必要的字段，要有默认值
- body是kv格式
- 不同的content-type影响body的格式
- content length

第二步send函数编写
- 在Request的构造器中收集必要的信息
- 设计一个send函数，把请求真实发送到服务器
- send函数应该是异步的，所以返回Promise

response 格式
`{% asset_img response.png %}`

第三步发送请求到服务端（重要）
- 设计支持已有的connection或者自己新建connection
- 收到数据传给parser
- 根据parser的状态resolve Promise

第四步response解析（重要）
- Response必须分段构造，所以我们要用一个 ResponseParser来 "装配"
- ResponseParser分配处理ResponseText，我们用状态机来分析文本的结构

最后一步response body解析
- Resonse的body可能根据Content-Type有不同的结构，因此我们会采用子Parser的结构来解决问题
- 以TrunkBodyParser为例，我们同样用状态机来处理body的格式

#### HTML解析
第一步 Parse模块的文件拆分
- 为了方便文件管理，把parser单独拆到文件中
- parser接受HTML文本作为参数，返回一颗DOM树

第二步 用FSM实现HTML的分析
- 用FSM来实现HTML的分析
- 在HTML标准中，已经规定了HTML的状态 [whatwg](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)
- Toy-Browser只挑选其中一部分状态，完成一个最简版本

第三步 解析标签
三种tag：
- 开始标签
- 结束标签
- 自封闭标签

总结：
- 主要的标签有：开始标签，结束标签和自封闭标签
- 在这一步我们暂时忽略属性

第四步 创建元素
- 在状态机中，除了状态迁移，我们还会要加入业务逻辑
- 我们在标签结束状态提交标签token

第五步 处理属性
- 属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理
- 处理属性的方式跟标签类似
- 属性结束时，把属性加到标签Token上

第六步 用token构建DOM树
Tree construction 第一步
- 从标签构建DOM树的基本技巧是使用栈
- 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
- 自封闭节点可视为入栈后立即出栈
- 任何元素的父元素是它入栈前的栈顶

第七步 将文本节点加到DOM树
- 文本节点与自封闭标签处理类似
- 多个文本节点需要合并

#### CSS计算
环境准备：
npm install css (css == css parser, 把css的代码变成 AST抽象语法树)
根据这颗抽象语法树，抽出各种CSS规则，应用到HTML元素上

第一步 收集CSS规则
- 遇到style标签时，我们把CSS规则保存起来
- 这里我们调用CSS Parser来分析CSS规则
- 仔细研究此库分析CSS规则的格式

第二步 添加调用
计算CSS时机
- 创建一个元素后，立即计算CSS
- 理论上，当我们分析一个元素时，所有CSS规则已经收集完毕
- 在真实浏览器中，可能遇到写在body的style标签，需要重新CSS计算的情况，这里我们忽略

第三步 获取父元素序列
- 在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
- 我们从上一步骤的stack，可以获取本元素所有的父元素
- 因此我们首先获取的是 ”当前元素“，所以我们获取得和计算父元素匹配的顺序是从内向外

第四步 选择器与元素的匹配
- 选择器也要从当前元素向外排列
- 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

第五步 计算选择器与元素匹配
- 根据选择器的类型和元素属性，计算是否与当前元素匹配
- 这里仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器
- 可选：实现复合选择器，实现支持空格的Class选择器

第六步 生成computed属性
- 一旦选择匹配，就应用选择器到元素上，形成computedStyle